\documentclass[titlepage]{report}

\usepackage{titlesec}
\usepackage{lipsum}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage[export]{adjustbox}
\usepackage[dvipsnames]{xcolor}
\usepackage{colortbl}

%setting for chapter font
\titleformat{\chapter}[display]
  {\Huge\bfseries}{}{1pt}{\Huge}
  
  

\title{\textbf{Milestone 1}}  


\begin{document}
\maketitle

\tableofcontents{}
\newpage

\chapter{Plan for milestone 1}
In this phase, we develop a plugin for OpenVINO and using Tensor Virtual Machine (TVM), we generate kernels in order to run a simple topology on a single FPGA. The generated kernels are customized for OpenVINO and synthesized for Stratix 10.
\chapter{Development of OpenVINO Plugin}
\begin{itemize}
\item Firstly, the deep learning deployment toolkit (dldt) github repository was integrated into the university gitlab server. 
\item A folder named Noctua\_plugin was created inside dldt and another folder named kernels was created inside Nocuta\_plugin to store the bitstreams (.aocx files).
\item The development process started by editing the classification sample application to parse the IR of the given input topology. 
\item This parsed IR, which is stored in a data structure called CNNNetwork, is then passed on to the plugin. 
\item A single file named fpga\_plugin.cpp retrieved the layer information from the IR, launched the kernels on the FPGA after passing them the required arguments.
\end{itemize} 
\subsection{Summary of the progress}
The developed plugin supports convolution, max pooling and fully connected layers as required by the simpleCNN topology.



\chapter{Using TVM to generate kernels}
\begin{itemize}
    \item Firstly, relay is imported which helps provide intermediate representation (IR) for the model.
    \item Next, tensorfow or caffe model (protobuf file) is imported and graph definition is created from the file with the help of tensorflow GraphDef class.
    \item On creating graph definition, it is imported into relay frontend to generate relay expression and parameters from tensorflow protobuf file. 
    \item The expression and parameters along with target host (OpenCL) are parsed to relay build function to create the final graph. 
\end{itemize}


\subsection{Summary of the progress}
The final graph created is used to generate the OpenCL code.


\chapter{Conclusion and feedback}


\end{document}
