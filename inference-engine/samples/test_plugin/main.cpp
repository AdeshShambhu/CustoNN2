// Copyright (C) 2018 Intel Corporation
// SPDX-License-Identifier: Apache-2.0
//

#include <fstream>
#include <vector>
#include <chrono>
#include <memory>
#include <string>

#include <inference_engine.hpp>
#include <ext_list.hpp>
#include <format_reader_ptr.h>

#include <samples/common.hpp>
#include <samples/slog.hpp>
#include <samples/args_helper.hpp>
#include "fpga_plugin.cpp"
#include "mpi.h"
#include "test_plugin.h"

using namespace InferenceEngine;

ConsoleErrorListener error_listener;

bool ParseAndCheckCommandLine(int argc, char *argv[])
{
    // ---------------------------Parsing and validation of input args--------------------------------------
    gflags::ParseCommandLineNonHelpFlags(&argc, &argv, true);
    if (FLAGS_h)
    {
        showUsage();
        return false;
    }
    slog::info << "Parsing input parameters" << slog::endl;

    if (FLAGS_ni < 1)
    {
        throw std::logic_error("Parameter -ni should be greater than zero (default 1)");
    }

    if (FLAGS_i.empty())
    {
        throw std::logic_error("Parameter -i is not set");
    }

    if (FLAGS_m.empty())
    {
        throw std::logic_error("Parameter -m is not set");
    }
    if(FLAGS_bitstream.empty()){
        showUsage();
        throw std::logic_error("Parameter -bitstream is not set");
    }

    return true;
}

/**
* @brief The entry point the Inference Engine sample application
* @file classification_sample/main.cpp
* @example classification_sample/main.cpp
*/
int main(int argc, char *argv[])
{
    try
    {
        slog::info << "InferenceEngine: " << GetInferenceEngineVersion() << slog::endl;

        // ------------------------------ Parsing and validation of input args ---------------------------------
        if (!ParseAndCheckCommandLine(argc, argv))
        {
            return 0;
        }

        /** This vector stores paths to the processed images **/
        std::vector<std::string> imageNames;
        parseInputFilesArguments(imageNames);
        if (imageNames.empty())
            throw std::logic_error("No suitable images were found");
        // -----------------------------------------------------------------------------------------------------

        // --------------------------- 1. Load Plugin for inference engine -------------------------------------
        slog::info << "Loading plugin" << slog::endl;
        InferencePlugin plugin = PluginDispatcher({FLAGS_pp, "../../../lib/intel64", ""}).getPluginByDevice(FLAGS_d);
        if (FLAGS_p_msg)
        {
            static_cast<InferenceEngine::InferenceEnginePluginPtr>(plugin)->SetLogCallback(error_listener);
        }

        /** Loading default extensions **/
        if (FLAGS_d.find("CPU") != std::string::npos)
        {
            /**
             * cpu_extensions library is compiled from "extension" folder containing
             * custom MKLDNNPlugin layer implementations. These layers are not supported
             * by mkldnn, but they can be useful for inferring custom topologies.
            **/
            plugin.AddExtension(std::make_shared<Extensions::Cpu::CpuExtensions>());
        }

        if (!FLAGS_l.empty())
        {
            // CPU(MKLDNN) extensions are loaded as a shared library and passed as a pointer to base extension
            auto extension_ptr = make_so_pointer<IExtension>(FLAGS_l);
            plugin.AddExtension(extension_ptr);
            slog::info << "CPU Extension loaded: " << FLAGS_l << slog::endl;
        }
        if (!FLAGS_c.empty())
        {
            // clDNN Extensions are loaded from an .xml description and OpenCL kernel files
            plugin.SetConfig({{PluginConfigParams::KEY_CONFIG_FILE, FLAGS_c}});
            slog::info << "GPU Extension loaded: " << FLAGS_c << slog::endl;
        }

        /** Setting plugin parameter for collecting per layer metrics **/
        if (FLAGS_pc)
        {
            plugin.SetConfig({{PluginConfigParams::KEY_PERF_COUNT, PluginConfigParams::YES}});
        }

        /** Printing plugin version **/
        printPluginVersion(plugin, std::cout);
        // -----------------------------------------------------------------------------------------------------

        // --------------------------- 2. Read IR Generated by ModelOptimizer (.xml and .bin files) ------------
        std::string binFileName = fileNameNoExt(FLAGS_m) + ".bin";
        slog::info << "Loading network files:"
                      "\n\t"
                   << FLAGS_m << "\n\t" << binFileName << slog::endl;
        MPI_Init(NULL, NULL);
        CNNNetReader networkReader;
        /** Reading network model **/
        networkReader.ReadNetwork(FLAGS_m);

        /** Extracting model name and loading weights **/
        networkReader.ReadWeights(binFileName);
        CNNNetwork network = networkReader.getNetwork();

        std::string modelName = fileNameNoExt(FLAGS_m);
        const int length_str = modelName.length();
        char *inputModel = new char[length_str + 1];
        strcpy(inputModel, modelName.c_str());

        slog::info << " Starting FPGA Launcher\n"
                   << modelName << slog::endl;
        //std::vector<std::string> input_imagePath;
        // input_imagePath.push_back(input_image_path.c_str());

        std::string cnn_modelArg = FLAGS_model;
        const int model_name_str = cnn_modelArg.length();
        char *cnn_model = new char[model_name_str + 1];
        strcpy(cnn_model, cnn_modelArg.c_str());
        //int num_devices = FLAGS_num_devices;

        // Bitstream directory
        std::string bitstream = FLAGS_bitstream;

        //Top N results;
        int TOP_N = FLAGS_nt;

        // Read Labels file and store it in a map
        std::string label_file_path = FLAGS_label;
        bool labelFilePresent = false;
        std::map<int, std::string> LabelMap;
        if (FLAGS_label.empty())
        {
            slog::warn << " -label parameter not set. Image classification results will not be mapped with labels of the model. " << slog::endl;
        }
        else
        {
            std::ifstream infile(label_file_path);

            if (infile.is_open())
            {
                std::string line;
                while (getline(infile, line))
                {
                    size_t pos = 0;
                    std::string delimiter = ":";
                    while ((pos = line.find(delimiter)) != std::string::npos)
                    {
                        std::string labelIndex = line.substr(0, pos);
                        std::string labelName = line.substr(pos + 1, line.length());
                        LabelMap.insert(std::pair<int, std::string>(std::atoi(labelIndex.c_str()), labelName));
                        line.erase(0, pos + delimiter.length());
                    }
                }
                infile.close();
                labelFilePresent = true;
            }
            else
            {
                slog::err << " Label file not found. Please check the Labels file path" << slog::endl;
                exit(-1);
            }
        }
        typedef std::chrono::high_resolution_clock Time;
        typedef std::chrono::duration<double, std::ratio<1, 1000>> ms;
        typedef std::chrono::duration<float> fsec;

        double total = 0.0;
        auto t0 = Time::now();
        int rank;
        MPI_Comm_rank(MPI_COMM_WORLD, &rank);
        std::vector<int> classificaitons = fpga_launcher(network, inputModel, imageNames, cnn_model, rank,TOP_N,bitstream);
        if (classificaitons.size() == 0)
        {
            slog::info << " No classification results in this node " << imageNames.at(0) << slog::endl;
        }
        else
        {
            slog::info << " Top-" << FLAGS_nt << " Image Classification for :" << imageNames.at(0) << slog::endl;
            slog::info << " ----------------------------------------------------- " << slog::endl;
            if (labelFilePresent)
            {
                for (int labelIndexFPGA : classificaitons)
                {
                    slog::info << " Label index: " << labelIndexFPGA << " - Label : " << LabelMap.find(labelIndexFPGA)->second << slog::endl;
                }
                slog::info << " ----------------------------------------------------- " << slog::endl;
            }
            else
            {
                for (int labelIndexFPGA : classificaitons)
                {
                    slog::info << " Label index: " << labelIndexFPGA << slog::endl;
                }
                slog::info << " Please match the above label indices with the \"Labels.txt\" of the model to see the classification results. \n\t For automatic mapping of labels, please provide \"-label\" argument while executing the plugin." << slog::endl;
                slog::info << " ----------------------------------------------------- " << slog::endl;
            }
        }

        auto t1 = Time::now();
        fsec fs = t1 - t0;
        ms d = std::chrono::duration_cast<ms>(fs);
        total += d.count();
        slog::info << "total inference time(ms): " << total << slog::endl;
    }
    catch (const std::exception &error)
    {
        slog::err << "" << error.what() << slog::endl;
        return 1;
    }
    catch (...)
    {
        slog::err << "Unknown/internal exception happened." << slog::endl;
        return 1;
    }

    slog::info << "Execution successful" << slog::endl;
    MPI_Finalize();
    return 0;
}
